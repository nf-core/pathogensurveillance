---
title: Pathogen Surveillance Report
params:
  inputs: "_test_data/2"
execute:
  echo: false
---

```{r knitr_settings}
knitr::opts_chunk$set(echo = FALSE, fig.width = 10, warning = FALSE)
```

```{r load_libraries, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)
library(readr)
library(knitr)
library(readr)
library(purrr)
library(yaml)
library(phylocanvas)
library(ape)
library(magrittr)
library(pheatmap)
library(tidyverse)
library(palmerpenguins)
library(ade4)
library(adegenet)
library(poppr)
library(ggtree)
library(igraph)
library(visNetwork)
library(phangorn)
library(ggplot2)
library(ggnewscale)
library(kableExtra)
library(plotly)
```

```{r parse_inputs}
# Parse metadata
group_path <- file.path(params$inputs, "inputs", "group_id.txt")
group <- read_lines(group_path)
ref_ids_path <- file.path(params$inputs, "inputs", "ref_ids.txt")
refs <- strsplit(read_lines(ref_ids_path), split = ';', fixed = TRUE)[[1]]
samp_data_path <- file.path(params$inputs, "inputs", "samp_data.csv")
all_samp_data <- read_csv(samp_data_path, show_col_types = FALSE)
all_samp_data$modified_id <- gsub(all_samp_data$sample, pattern = "-", replacement = "_", fixed = TRUE)
group_data <- strsplit(all_samp_data$report_group, split = ";")
all_groups <- unique(unlist(group_data))
samp_data <- all_samp_data[map_lgl(group_data, function(x) group %in% x), ]
ref_data_path <- file.path(params$inputs, "inputs", "ref_data.tsv")
ref_data <- read_tsv(ref_data_path, col_types = 'dcccccccccccccccddc')

# Parse sendsketch data
sendsketch_path <- file.path(params$inputs, "inputs", "sendsketch")
sketch_data <- map_dfr(list.files(sendsketch_path), function(path) {
    data <- read_tsv(file.path(sendsketch_path, path), skip = 2,
                     show_col_types = FALSE)
    id <- sub(path, pattern = '\\.txt$', replacement = '')
    return(bind_cols(sample_id = rep(id, nrow(data)), data))
})

# Parse variant data
variant_data_path <- file.path(params$inputs, "inputs", "variant_data")
snp_tree_paths <- list.files(variant_data_path, pattern = "\\.treefile$", full.names = TRUE)
vcf_paths <- list.files(variant_data_path, pattern = "\\.vcf\\.gz$", full.names = TRUE)
snp_align_paths <- list.files(variant_data_path, pattern = "\\.fasta$", full.names = TRUE)

# Parse ANI matrix
ani_matrix_path <- file.path(params$inputs, "inputs", "ani_matrix.csv")
ani_matrix <- read.csv(ani_matrix_path, check.names = FALSE)
rownames(ani_matrix) <- colnames(ani_matrix)

# Parse core gene phylogeny
core_phylo_path <- file.path(params$inputs, "inputs", "core_phylo.treefile")

# Parse quality control data
multiqc_path <- file.path(params$inputs, "inputs", "multiqc")
multiqc_report_path <- file.path(multiqc_path, 'multiqc_report.html')
quast_path <- file.path(params$inputs, "inputs", "quast")
quast_ref_names <- list.files(quast_path)
quast_report_paths <- file.path(quast_path, quast_ref_names, 'report.html')

# Parse version data
version_path <- file.path(params$inputs, "inputs", "versions.yml")
raw_version_data <- unlist(read_yaml(version_path))
version_data <- tibble(
    module = map_chr(strsplit(names(raw_version_data), split = '.', fixed = TRUE), `[`, 1),
    program = map_chr(strsplit(names(raw_version_data), split = '.', fixed = TRUE), `[`, 2),
    version = unname(raw_version_data)
)
```

# Summary

This report is produced by the **`nf-core/pathogensurveillance` pipeline** version {{< var version >}}.

| <!-- -->          | <!-- -->                             |
|-------------------|--------------------------------------|
| **Report group:** | `r group`                            |
| **Sample count:** | `r nrow(samp_data)`                  |
| **Last updated**  | `r format(Sys.time(), '%B %d , %Y')` |

## Status

Perhaps a table with a list of majors steps and a icon next to each for done/queued/failed.

## Sample plotly/ggtree tree from [here](https://plotly.com/ggplot2/dendrogram/)

```{r}
library(plotly)
library(ggplot2)
library(ggdendro)

model <- hclust(dist(USArrests), "ave")
dhc <- as.dendrogram(model)

data <- dendro_data(dhc, type = "triangle")
p <- ggplot(segment(data)) + 
      geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) + 
      coord_flip() + 
      scale_y_reverse(expand = c(0.2, 0)) +
      theme_dendro()

ggplotly(p)


```

## Sample Plotly graph

[see webstie to create plotly graph](https://stackoverflow.com/questions/56787941/embedding-dash-plotly-graphs-into-html) to create interactive trees:

<head>
  <!-- Plotly.js -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>

<body>
<h1>Something</h1>
<div><div id="d18660f3-1557-43c1-8f27-09292a9a8de7" style="height: 100%; width: 100%;" class="plotly-graph-div"></div><script type="text/javascript">window.PLOTLYENV=window.PLOTLYENV || {};window.PLOTLYENV.BASE_URL="https://plot.ly";Plotly.newPlot("d18660f3-1557-43c1-8f27-09292a9a8de7", [{"name": "Boats", "x": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "y": [9, 6, 2, 1, 5, 4, 6, 8, 1, 3], "type": "bar", "uid": "39c52ed4-e27d-4574-9cec-a3d50a8773a0"}, {"name": "Cars", "x": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "y": [19, 36, 12, 1, 35, 4, 6, 8, 1, 3], "type": "bar", "uid": "c0b658e9-bd5b-4c65-976d-1e03ba5836a3"}], {"title": {"text": "Title"}, "xaxis": {"tickangle": -45, "tickfont": {"color": "rgb(107, 107, 107)", "size": 14}, "title": {"text": "X axis"}}, "yaxis": {"tickfont": {"color": "rgb(107, 107, 107)", "size": 14}, "title": {"font": {"color": "rgb(107, 107, 107)", "size": 16}, "text": "Y axis"}}}, {"showLink": false, "linkText": "Export to plot.ly", "plotlyServerURL": "https://plot.ly"})</script><script type="text/javascript">window.addEventListener("resize", function(){Plotly.Plots.resize(document.getElementById("d18660f3-1557-43c1-8f27-09292a9a8de7"));});</script></div>
</body>

## Example Observable JS code

```{ojs}
//| code-fold: true
pdata = FileAttachment("palmer-penguins.csv").csv({typed: true})

Plot.plot({
  facet: {
    data: pdata,
    x: "sex",
    y: "species",
    marginRight: 80
  },
  marks: [
    Plot.frame(),
    Plot.rectY(pdata, 
      Plot.binX(
        {y: "count"}, 
        {x: "body_mass_g", thresholds: 20, fill: "species"}
      )
    ),
    Plot.tickX(pdata, 
      Plot.groupZ(
        {x: "median"}, 
        {x: "body_mass_g",
         z: d => d.sex + d.species,
         stroke: "#333",
         strokeWidth: 2
        }
      )
    )
  ]
})
```

## {{< bi clipboard-data >}} Input data

```{r}
samp_data %>%
    select(
        `Sample ID`=sample,
        `Forward Reads`=fastq_1,
        `Reverse Reads`=fastq_2,
        `Reference ID`=reference_id,
        `Reference`=reference) %>%
    DT::datatable()
```

## {{< bi sliders >}} Input settings

Add settings used to run Nextflow and the pipeline parameters. (Nik thinks this should go down at the end given that status is reported above).

# Identification

## Rapid ID to genus

The following table provides putative classifications of the samples based on a kmer analysis. It is important to note that these are preliminary identifications. The table incorporates several key metrics: Weighted Kmer IDentity (WKID), Average Nucleotide Identity (ANI), and Completeness. These metrics provide insights into the genomic similarity and representational completeness between the query and reference genomes.

```{r sketchtable, fig.width=5}
# Load additional packages for aesthetic formatting
#install.packages("kableExtra")

# Convert percentage fields from character to numeric
sketch_data$WKID <- as.numeric(gsub("%", "", sketch_data$WKID))
sketch_data$ANI <- as.numeric(gsub("%", "", sketch_data$ANI))
sketch_data$Complt <- as.numeric(gsub("%", "", sketch_data$Complt))

# Sort and filter data
final_table <- sketch_data %>%
  arrange(desc(sample_id), desc(WKID), desc(ANI), desc(Complt)) %>%  # Sort by sample_id, WKID, ANI, and Complt in descending order
  group_by(sample_id) %>%  # Group by sample_id
  slice_head(n = 1) %>%  # Take the first entry per group
  ungroup() %>%  # Remove grouping
  select(sample_id, WKID, ANI, Complt, taxName) %>%  # Select required columns
  rename(Sample = sample_id, 
         `WKID (%)` = WKID,
         `ANI (%)` = ANI,
         `Completeness (%)` = Complt,
         `Top Hit` = taxName)  # Rename columns

# Define a function called 'bordered_bar' that takes two arguments: 'value' and 'color'
bordered_bar <- function(value, color) {
  sprintf('<div style="border: 1px solid gray; width: 100%%; border-radius: 12px;">
            <div style="width: %s%%; background-color: %s; border-radius: 12px; text-align: center;">%s</div>
           </div>', 
          value, color, value)
}

# Apply the bordered_bar function to the relevant columns
final_table$`WKID (%)` <- sapply(final_table$`WKID (%)`, function(x) bordered_bar(x, 'lightblue'))
final_table$`ANI (%)` <- sapply(final_table$`ANI (%)`, function(x) bordered_bar(x, 'lightgreen'))
final_table$`Completeness (%)` <- sapply(final_table$`Completeness (%)`, function(x) bordered_bar(x, 'lightpink'))

# Render the table using DT for HTML output, which will make it interactive
DT::datatable(final_table, 
          options = list(
            pageLength = 10,  # Show 10 entries per page
            autoWidth = TRUE,  # Automatically adjust column width
            columnDefs = list(
              list(width = '150px', targets = c(1, 2, 3))
            ),
            searchHighlight = TRUE  # Highlight search results
          ),
          rownames = FALSE,  # Hide row numbers
          escape = FALSE  # Necessary if your table has HTML content, like the bordered bars
)



# Render the table using kable and kableExtra for HTML output
#final_table %>%
#  knitr::kable("html", escape = F, align = c('l', 'c', 'c', 'c', 'l')) %>%
#  kable_styling(bootstrap_options = "striped", full_width = F) %>%
#  column_spec(2, extra_css = "width: 150px;") %>%
#  column_spec(3, extra_css = "width: 150px;") %>%
#  column_spec(4, extra_css = "width: 150px;") %>%
#  column_spec(5, extra_css = "width: 350px;") %>%
#  column_spec(1:5, extra_css = "font-size: 14px;")


```

::: callout-note
WKID represents the Weighted Kmer IDentity, adjusted for genome size differences. ANI, or Average Nucleotide Identity, is derived from WKID and kmer length. Completeness indicates the percentage of the reference genome represented in the query, and is derived from WKID and KID.
:::

# Summary of Species Proportions FYI, STILL WORKING ON THIS--Camilo

This section provides an overview of the proportions of different species in the report.

> From NIK: I think package plotly cand o this and is already laoded, see [https://plotly.com/r/treemaps/](https://plotly.com/r/treemaps/). 

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(billboarder)
library(dplyr)

species_summary <- final_table %>%
  group_by(`Top Hit`) %>%
  summarise(Freq = n()) 

# Create the treemap chart
billboarder() %>% 
  bb_treemapchart(
    data = species_summary, 
    mapping = aes(x = `Top Hit`, y = Freq),
    label = list(show = TRUE, threshold = 0.03),
    tile = "binary" 
  ) %>% 
  bb_data(
    labels = list(colors = "#FFF")
  ) %>% 
  bb_color(
    palette = colorRampPalette(c("#08519C", "#9ECAE1"))(nrow(species_summary)) 
  )

```

Here is how we can display the whole taxonomy with plotly using the `sunburst` and `treemap` plot types:

```{r fig.height=8}
library(metacoder)

top_hits <- sketch_data %>%
  arrange(desc(sample_id), desc(WKID), desc(ANI), desc(Complt)) %>%  # Sort by sample_id, WKID, ANI, and Complt in descending order
  group_by(sample_id) %>%  # Group by sample_id
  slice_head(n = 1) %>%  # Take the first entry per group
  ungroup()

x <- parse_tax_data(tax_data = top_hits,
                    class_cols = 'taxonomy',
                    class_key = c("taxon_rank", "taxon_name"),
                    class_regex = "([a-z]+)?:?([a-zA-Z0-9.-_, ]+)",
                    class_sep = ";") %>%
    filter_taxa(taxon_ranks == "s", supertaxa = TRUE)

# A more complex test data set included in metacoder
# x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
#                    class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
#                    class_regex = "^(.+)__(.+)$")


duplicated_names <- taxon_names(x)[duplicated(taxon_names(x))]
unique_taxon_names <- paste0(taxon_names(x), " (", taxon_ranks(x), ")")
names(unique_taxon_names) <- taxon_ids(x)
unique_tax_names <- ifelse(taxon_names(x) %in% duplicated_names, unique_taxon_names, taxon_names(x))
names(unique_tax_names) <- taxon_ids(x)

plot_data <- x$edge_list
plot_data$count <- n_obs_1(x)[plot_data$to]
plot_data$from <- unique_tax_names[plot_data$from]
plot_data$to <- unique_tax_names[plot_data$to]

plot_ly(
    type='treemap',
    labels=plot_data$to,
    parents=plot_data$from,
    values=plot_data$count,
    textinfo="label+value+percent parent+percent entry+percent root",
    domain=list(column=0))

plot_ly(
    type='sunburst',
    labels=plot_data$to,
    parents=plot_data$from,
    values=plot_data$count,
    domain=list(column=0))
```


## Rigorous ID to species or subspecies

::: panel-tabset
### Core phylogeny

```{r id_core_phylo, eval = length(read_lines(core_phylo_path)) > 0}
convert_id <- function(ids) {
    gsub(ids, pattern = "[.-]", replacement = "_")
}

core_tree <- ape::read.tree(core_phylo_path)

# Identify which tips are samples and references
sample_ids <- core_tree$tip.label[core_tree$tip.label %in% convert_id(samp_data$sample)]

# Root tree 
colnames(ani_matrix) <- convert_id(colnames(ani_matrix))
rownames(ani_matrix) <- colnames(ani_matrix)
group_ani <- ani_matrix[rownames(ani_matrix) %in% core_tree$tip.label, colnames(ani_matrix) %in% core_tree$tip.label]
core_tree <- root(core_tree, names(which.min(colMeans(group_ani[sample_ids, ]))))

# Set tip labels to taxon names for reference sequences
# TODO: need a more reliable way to get IDs
name_key <- c(
  ref_data$Organism, 
  samp_data$sample
)
names(name_key) <- c(
  convert_id(ref_data$LastMajorReleaseAccession),
  convert_id(samp_data$sample)
)
core_tree$tip.label <- name_key[core_tree$tip.label]

# Plot tree
phycanv <- phylocanvas(core_tree, treetype = "rectangular", alignlabels = T, showscalebar = T, width = "100%")
for (x in name_key[sample_ids]) {
  phycanv <- style_node(phycanv, x, labelcolor = "green", labeltextsize = 30)
}
    
phycanv
```

### ANI Neighbor-Joining Tree
```{r ANI NJ tree, include=TRUE, height=8, width=8}
#Check-what is the significance of the entry in ANI matrix with the suffix "_assembly". It isn't in "samp_data" or "ref_data". Will this be in each dataset? Right now my code assumes this. 

convert_id <- function(ids) {
    gsub(pattern = "[.-]", replacement = "_", x = ids)
}

# Convert data.frame to matrix
ani_matrix_format <-as.matrix(ani_matrix)

# Convert ANI similarity values to distances
dist_matrix <- 1 - ani_matrix_format

colnames(dist_matrix) <- convert_id(colnames(dist_matrix))
rownames(dist_matrix) <- convert_id(rownames(dist_matrix))

nj_tree <- nj(dist_matrix)

# Handle negative branch lengths-this is one idea, but if there is a better option, please change
nj_tree$edge.length[nj_tree$edge.length < 0] <- 1e-4  

sample_ids <- nj_tree$tip.label[nj_tree$tip.label %in% convert_id(samp_data$sample)]

group_ani <- dist_matrix[rownames(dist_matrix) %in% nj_tree$tip.label, colnames(dist_matrix) %in% nj_tree$tip.label]

nj_tree <- root(nj_tree, names(which.max(colMeans(group_ani[sample_ids, ]))))

# Create a name key to relabel the tree tips
#We have 1 entry with suffix assembly-may need to organize or rename to clarify to user what this sample is


assembly_entries <- rownames(ani_matrix_format)[grepl("_assembly$", rownames(ani_matrix_format))]

name_key <- c(
  setNames(ref_data$Organism, convert_id(ref_data$LastMajorReleaseAccession)),
  setNames(samp_data$sample, convert_id(samp_data$sample)),
  setNames(assembly_entries, assembly_entries)
)

# Relabel the tree tips
nj_tree$tip.label <- name_key[nj_tree$tip.label]

# Visualize-used phycanvas 
# Sadly, for now-won't render if part of a tabular panel
#phycanv_nj <- phylocanvas(nj_tree, treetype = "rectangular", alignlabels = T, showscalebar = T, width = "100%")
#for (x in name_key[sample_ids]) {
#  phycanv_nj <- style_node(phycanv_nj, x, labelcolor = "green", labeltextsize = 30)
#}
    
#phycanv_nj

##Used static ggtree because I was having trouble rendering phycanvas option. It doesn't work if output is part of an output with multiple tabs. I can also try to convert to ggplotly object but you lost a lot of the ggtree functionality

# Basic tree visualization with ggtree
ggtree_ani <- ggtree(nj_tree) +
  geom_tippoint() +
  geom_tiplab(aes(color=ifelse(label %in% name_key[sample_ids], "#24B064", "black")), size=2.2) +
  scale_color_identity(guide=FALSE) +
  xlim(c(NA, max(nj_tree$edge.length) * 1.5))


ggtree_ani

```

### ANI heatmap and dendrogram

*TODO Relabel the row names if we opt to use heatmap, otherwise, maybe just NJ tree. Martha will look at this.*

```{r ANI dendrogram, fig.height = 8, fig.width=8}
ani_matrix_format <-as.matrix(ani_matrix)
colnames(ani_matrix_format) <- convert_id(colnames(ani_matrix_format))
rownames(ani_matrix_format) <- convert_id(rownames(ani_matrix_format))


heatmap_ani <- pheatmap(ani_matrix, show_rownames = T, labels_row =colnames(ani_matrix))


heatmap_ani
```



:::

# Genetic diversity in the group(s)

*Things to address:*

1.  There are lots of NAs in metadata. I ran into issues when trying run poppr and I was trying to select a specific column to color nodes. As a quick workaround, changed these to 'unknown', but what is a better solution?
2.  The assembly prefix in sample names present in SNP aln output and treefile need to be addressed. In initial tool testing stage, I (Martha) have provided some quick workarounds, but this should be addressed at a larger level.
3. Need to clarify to use what REF is in the SNP tree or else rename

```{r div_parse_inputs}
snp_trees <- ape::read.tree(snp_tree_paths)
snp_alignment <- ape::read.dna(snp_align_paths, format =  "fasta")
#Rename sample names so they don't have prefixes-may be better way
```

## Genetic diversity in sample
::: panel-tabset
### SNP tree

**Phylocanvas option**
```{r snp_tree_config, include=TRUE}
#Will tidy up code once we finalize which tree program to use.

#Rename tree tip labels
oldtips<-snp_trees$tip.label

#TODO generalize for any prefix
#assume REF is always in first position
newtips<- gsub("^[^_]+(?:_[^_]+)*_", "", oldtips)

#SNP output now has new prefix-is there a better way to deal with this, and will it be changing again? 
snp_trees$tip.label<-newtips

# Root tree
#option1
snp_trees_rootref <- root(snp_trees, "REF")
#option2
snp_trees_midpoint<-midpoint(snp_trees)

#For phycanvas version-much simpler code-but have a ggtree and ggploty version below
phycanv_snp <- phylocanvas(snp_trees_midpoint, treetype = "rectangular", alignlabels = T, showscalebar = T, width = "100%")
for (x in name_key[sample_ids]) {
  phycanv_snp <- style_node(phycanv_snp, x, labelcolor = "#24B064", labeltextsize = 30)
}
    
phycanv_snp
```

**gtree and ggplotly option**

We need to decide on best tree package. Here I experimented with ggtree and ggplotly. Requires many more lines of code than Phylocanvas. If we use ggtree alone, we lose interactivity, but may look nicer.

```{r ggtree, height=10, width=8, include=TRUE}
#One way to parse metadata file so we can color tips in a descriptive way

#add REF to metadata-only provide accession info (and maybe genus and species)
samp_data2<-samp_data
new_row <- data.frame(matrix(ncol = ncol(samp_data2), nrow = 1))
colnames(new_row) <- colnames(samp_data2)

new_row$sample <- "REF"

#Didn't want to mess with original data frame but this could be revised or simplified-depending on if we want to use ggtree or phylocanvas. Not an elegant solution either way. 
samp_data2 <- rbind(samp_data2, new_row)
samp_data2 <- samp_data2[match(snp_trees_midpoint$tip.label, samp_data2$sample), ]

#We can revise, but one way to color the samples as one color, the ref as another
samp_data2$text_color <- "#24B064"
samp_data2$text_color[samp_data2$sample == "REF"] <- "black"

#Couldn't use some of ggtree functions with plotly, so here is a workaround
snp_tree1 <- fortify(snp_trees_midpoint)

# Merge it with your samp_data2 for color information
snp_tree1 <- merge(snp_tree1, samp_data2, by.x="label", by.y="sample")

# Using theme_minimal for a cleaner background
ggtree_snptree <- ggtree(snp_trees_midpoint, size=0.5) + # Adjusted branch size
  # Coloring nodes and adjusting size for visibility
  geom_segment(data=snp_tree1, aes(xend = x + 0.35, yend = y, x = x, y = y), xend = snp_tree1$x + 0.35, color = "lightgray") +
  geom_point(data=snp_tree1, aes(x=x, y=y, color="black"), show.legend = FALSE, size=3) +
  geom_text(data=snp_tree1, aes(x = x + 0.44 + 0.03, y = y, label = label, color=text_color), size=3, hjust=0, vjust=0.5, fontface="bold") +
  scale_color_identity() +
  theme(legend.position = "none")

# Converting to more interactive tree. Work on adjusting what is shown when cursor is on sample. 
ggtree_interactive <- ggplotly(ggtree_snptree)
ggtree_interactive
```

```{asis div_no_snp_phylo, echo = is.null(snp_trees)}
There is no tree to draw, probably because there were too few samples.
More info will be added later.
```

:::

## Minimum spanning network

### *Questions to address*

1.  Important discussion point-for running poppr, will user decide on SNP threshold? This differs depending on dataset. Can we use something like poppr *cutoff_predictor* function?

*Martha is actively experimenting. So far looking into Visnetwork, but another option is networkD3?*

```{r poppr_config}
#Specific to output from perl script vcftosnpaln, so need to extract REF from genind (ref remains after using )
snp_aln.gi <- DNAbin2genind(snp_alignment)
snp_aln.gi <- snp_aln.gi[indNames(snp_aln.gi) != "REF"]

#Extract just sample data for relevant sample group(s)? Way to get this from other output and just pull here? 

#Need to rename samples so no longer have prefix (may be better way)
genind_names<-indNames(snp_aln.gi)
cleaned_names <- gsub("^[^_]+(?:_[^_]+)*_", "", genind_names)
indNames(snp_aln.gi) <- cleaned_names
```

### MLG table (maybe helpful to include-not sure)

```{r mlg_config}
mat <- match(indNames(snp_aln.gi), samp_data$sample)
# samp_data <- samp_data[mat, ]

# Convert to genclone
snp_genclone <- as.genclone(snp_aln.gi)

# Filter genotypes at 5 nucleotides (with the default farthest neighbor algo)
mlg.filter(snp_genclone, distance = bitwise.dist, percent = FALSE) <- 6

idlist<-mlg.id(snp_genclone)

mlglist<-data.frame("MLG","strain")
colnames(mlglist) <- c("V1","V2")
for (name in names(idlist)) {
  newframe<-as.data.frame(cbind(paste0("MLG","_",name),idlist[[name]]))
  mlglist<-rbind(mlglist,newframe)
}

colnames(mlglist)<-c("MLG","strain")
mlglist<-mlglist[mlglist$strain != "strain",]
#make a prettier table
mlglist
```

### Experimenting with less subjective ways to provide SNP cutoff

Please revise as needed. I think we need a better approach to coming up with SNP threshold-as shown in code chunk above. Providing arbitrary cutoff for all datasets will sometimes not be meaningful and even incorrect.

```{r mlg_config_test, eval = FALSE}
#Experimenting with less subjective approach to identifying good threshold for considering if two samples have the same genotype

snpdist_stats<-filter_stats(snp_genclone)
if (length(snpdist_stats$farthest$THRESHOLDS) == 1) {
    print(farthest_thresh <- snpdist_stats$farthest$THRESHOLDS)
} else {
    print(farthest_thresh <- cutoff_predictor(snpdist_stats$farthest$THRESHOLDS))
}
mlg.filter(snp_genclone, distance = bitwise.dist) <- farthest_thresh
idlist2<-mlg.id(snp_genclone)

mlglist2<-data.frame("MLG","strain")
colnames(mlglist2) <- c("V1","V2")
for (name in names(idlist2)) {
  newframe<-as.data.frame(cbind(paste0("MLG","_",name),idlist2[[name]]))
  mlglist2<-rbind(mlglist2,newframe)
}

colnames(mlglist2)<-c("MLG","strain")
mlglist2<-mlglist2[mlglist2$strain != "strain",]
#make a prettier table
mlglist2
```

### Poppr MSN

Martha-need to resolve issues with key. There is an extra repeated node in legend. 

```{r poppr msn, fig.height = 10, eval = nrow(samp_data) > 2}
# Create a minimum spanning network with filtered data
#Still have issues with metadata-reference seq has none-need way to include? 

#NOTE-cannot have NAs in metadata-for temp fix, changed to NA-may need better solution
samp_data <- purrr::map_dfc(samp_data, function(col) ifelse(is.na(col), "unknown", col))

samp_data$nusery <- as.factor(samp_data$nusery)

myColors <- rainbow(length(unique(samp_data$nusery))) 
names(myColors) <- levels(samp_data$nusery)
#myColors["Other"] <- "#808080"

strata(snp_genclone) <- samp_data[, c(1:15)]
setPop(snp_genclone) <- ~nusery

ms.loc <- poppr.msn(snp_genclone,
                    distmat = bitwise.dist(snp_genclone, percent = FALSE),
                    include.ties = TRUE,
                    showplot = FALSE) # show nothing

#ms.loc$graph[]
#ms.loc
#str(ms.loc)
the_edges <-igraph::E(ms.loc$graph)$weight
edges<-as.list(the_edges)

# Plot a pretty plot
set.seed(8)
plot_poppr_msn(
  snp_genclone ,
  poppr_msn = ms.loc,
  palette = myColors,
  mlg = FALSE,
  quantiles = FALSE,
  wscale = FALSE,
  inds="None",
  layfun = igraph::layout_with_lgl,
  edge.label = the_edges,
  edge.label.font = 2,
  edge.label.cex = 1,
  edge.lable.family = "Helvetica",
  edge.label.color = "darkslateblue"
  
)
```

### Visnetwork minimum spanning network

*Just started, but needs some work to make a comparable MSN to the one above-including legends. Hard to color nodes like in poppr as pie chart. Need to remove sample names from nodes*

```{r visnetwork_setup, eval = nrow(samp_data) > 2}
node_data <- data.frame(
  id = V(ms.loc$graph)$name,
  label = V(ms.loc$graph)$name,
  group = V(ms.loc$graph)$color,
  size = V(ms.loc$graph)$size
)
node_data$value <- node_data$size.Freq

node_data$color <- ms.loc$colors[node_data$group]
node_groups <- lapply(names(ms.loc$colors), function(group_name) {
  list(color = list(background = ms.loc$colors[group_name], border = 'black'))
})
names(node_groups) <- names(ms.loc$colors)
edges_data <- get.data.frame(ms.loc$graph, what="edges")
edges_data$title <- paste("Distance:", edges_data$weight)
edges_data$arrows <- NA

visNetwork(node_data, edges_data) %>%
  visGroups(groupname = node_groups) %>%
  visNodes(shape = "dot", color = node_data$color) %>%
  visInteraction(dragNodes = TRUE, dragView = TRUE, hideEdgesOnDrag = FALSE) %>% 
  #visEdges(arrows = "to") %>%
  visPhysics(stabilization = FALSE) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)
```

### Network D3 experiment

# Quality control

-   A quick indicator of status of each step.

## Input data quality

-   multiqc link

## Downloaded references

-   quast
-   table with rows for each sample with info on references chosen
    -   sample id
    -   reference id
    -   ANI between sample and reference
-   table with one row per reference (taxon id, GSA id, classification, link to ncbi)
-   sourmash output (tree?)

## Assembly and annotation

-   depth of coverage
-   quast link
-   BUSCO gene content?
-   bakta output?

## Variant calling?

-   vcfr for plots
-   iqtree model selection, number of informative sites, indels

## Core genome phylogeny

-   core gene info (how many genes, length, paralogs)
-   outlier samples causing few genes to be chosen
-   iqtree model selection, number of informative sites, indels

# References

## {{< fa flask >}} Methods

The `pathogen surveillance` pipeline used the following tools that should be referenced as appropriate:

-   A sample is first identified to genus using sendsketch and further identified to species using sourmash [@brown2016sourmash].
-   The `nextflow` data-driven computational pipeline enables deployment of complex parallel and reactive workflows [@di2017nextflow].

## {{< bi gear-wide-connected >}} Analysis software

```{r}
DT::datatable(version_data)
```

## version and packages

```{r, include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```

```{r}
sessionInfo()
```

## {{< ai doi >}} Bibliography

::: {#refs}
:::

# About

{{< bi file-earmark-person >}} The **`nf-core/pathogen surveillance` pipeline** was developed by: Zach Foster, Martha Sudermann, Camilo Parada-Rojas, Fernanda Iruegas-Bocardo, [Jeff Chang](http://changlab.cgrb.oregonstate.edu/) and [Nik Grunwald](http://grunwaldlab.cgrb.oregonstate.edu/).

Other contributors include: [Alex Weisberg](https://alexandra-weisberg.com/), ...

:::{.callout-tip}
## Feedback

To contribute, provide feedback, or report bugs please visit our [github repository](https://github.com/nf-core/pathogensurveillance).
:::

Please cite this pipeline and nf-core in publications as follows: 

{{< bi file-earmark-pdf-fill >}} Foster et al. 2024. PathogenSurveillance: A nf-core pipeline for rapid analysis of pathogen genome data. In preparation.

{{< bi file-earmark-pdf-fill >}} Di Tommaso, Paolo, Maria Chatzou, Evan W Floden, Pablo Prieto Barja, Emilio Palumbo, and Cedric Notredame. 2017. Nextflow Enables Reproducible Computational Workflows. Nature Biotechnology 35 (4): 316â€“19. https://doi.org/10.1038/nbt.3820.

Icons for this report were sampled from [Bootstrap Icons](https://icons.getbootstrap.com), [Freepick](https://www.freepik.com), [Academicons](https://jpswalsh.github.io/academicons/), and [Font Awesome](https://fontawesome.com).